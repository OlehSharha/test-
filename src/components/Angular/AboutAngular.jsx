import React, { useState } from "react";
import box3 from '../../sharedScreen/Screenshot3.png'
import box4 from '../../sharedScreen/Screenshot4.png'
import box5 from '../../sharedScreen/Screenshot5.png'
import box6 from '../../sharedScreen/Screenshot6.png'
import box7 from '../../sharedScreen/Screenshot7.png'

export const AboutAngular = () => {
  const [isOpen, setIsOpen] = useState(false);

  const handleClose = () => {
    setIsOpen(false);
  };

  const handleOpen = () => {
    setIsOpen(true);
  };

  return (
    <div className="angular">
      {isOpen ? (
            <section className="answers">
              <button
                className="but"
                type="button"
                onClick={() => {
                  handleClose();
                }}
              >
                <p>Close answers about Angular</p>
              </button>
				<h3>
				1. Яка різниця між *ngIf і [hidden]?
				</h3>
        <h3>Відповідь:</h3>
				<p> основна різниця між *ngIf та [hidden] полягає в тому, що *ngIf дозволяє вставляти або видаляти елемент з DOM, в залежності від умови, а [hidden] приховує елемент на сторінці, залишаючи його в DOM. Вибір того, який підхід використовувати, залежить від конкретної ситуації та потреб користувачів.</p>

				<h3>
				2.Що таке Observable??
				</h3>
        <h3>Відповідь:</h3>
				<p>Observable - це об'єкт, який представляє потік асинхронних даних в програмі на мові TypeScript або JavaScript. Він може бути використаний для передачі даних між компонентами, сервісами, модулями</p>

				<h3>
				3. Розглянемо наступний компонент:

				</h3>

        <img src={box3} alt="" />
        <h3>
        Виберіть правильні твердження про його використання (в іншому шаблоні компонента або модулі).
        (Виберіть усі прийнятні відповіді.)<br/>
        1.{`<welcome name="TestDome"></welcome> відображатиме: "Welcome to TestDome!".`}<br/>
        2.{`<welcome></welcome> нічого не відображатиме.`}<br/>
        3.{`@NgModule({ declarations: [ WelcomeComponent ] }) export class WelcomeModule {}
         повідомляє, що компонент привітання належить модулю привітання.`}<br/>
        4.{` <hello name="{{ name }}"></hello> відображатиме: "Welcome to name!".`}<br/>
        </h3>
        <h3>Відповідь:</h3>
				<p>Всі відповіді коректні окрім 4 тому що компонент{`<hello>`} не існує і він не є зареєстрованим.</p>

				<h3>
				4. Розглянемо наступний компонент, який можна використовувати для моделювання тварини та її шуму.?
				</h3>

        <img src={box4} alt="box" />
        <h3>
        Виберіть правильні твердження про його використання (в іншому шаблоні компонента або модулі).
        (Виберіть усі прийнятні відповіді.)<br/>
        1.{`Component, Input і Output всі необхідні імпорти цього компонента.`}<br/>
        2.{`При включенні компонента AnimalNoise у шаблон мають бути вказані вхідні дані як тварин, так і шуму.
`}<br/>
        3.{`Параметр 'animal' у оголошенні @Input ('animal') не змінює інтерфейс компонента.
`}<br/>
        4.{` При включенні до шаблону компонентів компонент AnimalNoise створює діапазон, що містить інтерполіроване ім'я тварин і кнопку, прив'язану до makeNoise().`}<br/>
        5.{`Компонент AnimalNoise може бути включений в інший шаблон за допомогою тега <AnimalNoise>.`}
        </h3>
        <h3>Відповідь:</h3>
				<p>1 Component та Input є необхідними імпортами для цього компонента, але Output не використовується тут, тому це твердження є неправильним.<br/>
        2 Лише animal є обовязковим а noise ні <br/>
        3 Це твердження є правильним. @Input('animal') створює аліас для властивості animal, який може використовуватись в шаблоні, але не змінює інтерфейс компонента. <br/>
        4  Це твердження є частково правильним - компонент містить інтерпольоване ім'я тварин та кнопку, прив'язану до методу makeNoise(), але не створює діапазон.<br/>
        5 Тег  {`<AnimalNoise>`} неправильний - він повинен бути написаний з малих літер (тобто {`<animal-noise>`}) та використовувати ім'я компонента, а не селектор. Тому це твердження є неправильним.<br/>
        </p>

				<h3>
				5. Розглянемо наступний модуль програми:

				</h3>
        <img src={box5} alt="" />
				<h3>
        Які з таких тверджень щодо поведінки маршрутизаторів є правильними?
(Виберіть усі прийнятні відповіді.)<br/>
        1.{`Доступ до домашнього компонента можливий лише через перенаправлення кореневої URL-адреси.`}<br/>
        2.{`Параметр id не є обов'язковим, коли виконується виклик / detail / URL.

`}<br/>
        3.{`Необов'язкові параметри можуть бути передані до будь-якого компонента через параметри запиту ActivatedRoute.
`}<br/>
        4.{`/detail/100 використовуватиме <router-outlet name='route1'> для визначення позиції виду.`}<br/>
        5.{`Route, який перенаправляє на HomeComponent, активується на тих самих маршрутах, якщо властивість pathMatch: 'full' була видалена.
.`}
        </h3>
        <h3>Відповідь:</h3>
				<p>Перші три правильні<br/>
        4 Неправильно - дана URL-адреса містить параметр id, а не ім'я виду<br/>
        5 Неправильно -  властивість pathMatch: 'full' означає, що шлях повинен співпадати повністю, включаючи початок і кінець URL-адреси</p>

				<h3>
				6. Розглянемо наступні два базові класи, Positionable і Rotatable, і похідний клас MovingObject:

				</h3>
        <img src={box6} alt="" />
				<h3>
        Виберіть правильні твердження.
(Виберіть усі прийнятні відповіді.)<br/>
        1.{`Функція applyMixins застосовує реалізації Positionable і Rotatable до MovingObject.`}<br/>
        2.{`Компілятор TypeScript підкреслить, що властивість "align" відсутня для типу MovingObject.
.
`}<br/>
        3.{`Оскільки MovingObject реалізує Rotatable, виклик mover.rotate(30) нічого не зробить.

`}<br/>
        4.{` Клас Positionable можна змінити на інтерфейс без помилок компілятора.
`}<br/>
        5.{`Властивості MovingObject необхідні як резервні для задоволення компілятора TypeScript.`}
        </h3>
        <h3>Відповідь:</h3>
				<p>1 - Функція applyMixins застосовує реалізації Positionable і Rotatable до MovingObject - правильне.</p>

				<h3>
				7. Розглянемо такі компоненти:

				</h3>
        <img src={box7} alt="box" />
				<h3>
        Нижче наведено файл address-list.component.html. Заповніть пробіли, щоб шаблон відображав один елемент li на адресу, і коректно пов'язував кожну адресу з полем AddressComponent.<br/>
        {`<ul>`} <br/>{`
        <li ="let address of ">`}<br/>{`
            <app-address ="address"></app-address>`}<br/>{`
        </li>`} <br/>{`
    </ul>`}<br/>

        </h3>
        <h3>Відповідь:</h3>
				<p>Для того щоб код працював потрібно внести такі зміни: {`<ul>
    <li *ngFor="let address of addresses">
        <app-address [address]="address"></app-address>
    </li>

</ul>`} <br/> В даному шаблоні використовується структурна директива *ngFor, щоб ітерувати по масиву addresses та відображати кожну адресу в окремому елементі li.</p>
            </section>
      ) : (
        <button
          className="but"
          type="button"
          onClick={() => {
            handleOpen();
          }}
        >
          <p>Open answers about Angular</p>
        </button>
      )}
    </div>
  );
};
