/* eslint-disable react/no-unescaped-entities */
/* eslint-disable max-len */
import React, { useState } from 'react';
import box3 from '../../sharedScreen/Screenshot3.png';
import box4 from '../../sharedScreen/Screenshot4.png';
import box5 from '../../sharedScreen/Screenshot5.png';
import box6 from '../../sharedScreen/Screenshot6.png';
import box7 from '../../sharedScreen/Screenshot7.png';

export const AboutAngular = () => {
  const [isOpen, setIsOpen] = useState(false);

  const handleClose = () => {
    setIsOpen(false);
  };

  const handleOpen = () => {
    setIsOpen(true);
  };

  return (
    <div className="angular">
      {isOpen ? (
        <section className="answers">
          <button
            className="but"
            type="button"
            onClick={() => {
              handleClose();
            }}
          >
            <p>Close answers about Angular</p>
          </button>
          <h3>
            1. Яка різниця між *ngIf і [hidden]?
          </h3>
          <h3>Відповідь:</h3>
          <p> основна різниця між *ngIf та [hidden] полягає в тому, що *ngIf дозволяє вставляти або видаляти елемент з DOM, в залежності від умови, а [hidden] приховує елемент на сторінці, залишаючи його в DOM. Вибір того, який підхід використовувати, залежить від конкретної ситуації та потреб користувачів.</p>

          <h3>
            2.Що таке Observable??
          </h3>
          <h3>Відповідь:</h3>
          <p>Observable - це обєкт, який представляє потік асинхронних даних в програмі на мові TypeScript або JavaScript. Він може бути використаний для передачі даних між компонентами, сервісами, модулями</p>

          <h3>
            3. Розглянемо наступний компонент:

          </h3>

          <img src={box3} alt="" />
          <h3>
            Виберіть правильні твердження про його використання (в іншому шаблоні компонента або модулі).
            (Виберіть усі прийнятні відповіді.)
            <br />
            1.
            {`<welcome name="TestDome"></welcome> відображатиме: "Welcome to TestDome!".`}
            <br />
            2.
            {`<welcome></welcome> нічого не відображатиме.`}
            <br />
            3.
            {`@NgModule({ declarations: [ WelcomeComponent ] }) export class WelcomeModule {}
         повідомляє, що компонент привітання належить модулю привітання.`}
            <br />
            4.
            {` <hello name="{{ name }}"></hello> відображатиме: "Welcome to name!".`}
            <br />
          </h3>
          <h3>Відповідь:</h3>
          <p>
            Всі відповіді коректні окрім 4 тому що компонент
            {`<hello>`}
            {' '}
            не існує і він не є зареєстрованим.
          </p>

          <h3>
            4. Розглянемо наступний компонент, який можна використовувати для моделювання тварини та її шуму.?
          </h3>

          <img src={box4} alt="box" />
          <h3>
            Виберіть правильні твердження про його використання (в іншому шаблоні компонента або модулі).
            (Виберіть усі прийнятні відповіді.)
            <br />
            1.
            Component, Input і Output всі необхідні імпорти цього компонента.
            <br />
            2.
            {`При включенні компонента AnimalNoise у шаблон мають бути вказані вхідні дані як тварин, так і шуму.
`}
            <br />
            3.
            {`Параметр 'animal' у оголошенні @Input ('animal') не змінює інтерфейс компонента.
`}
            <br />
            4.
            {` При включенні до шаблону компонентів компонент AnimalNoise створює діапазон, що містить інтерполіроване ім'я тварин і кнопку, прив'язану до makeNoise().`}
            <br />
            5.
            {`Компонент AnimalNoise може бути включений в інший шаблон за допомогою тега <AnimalNoise>.`}
          </h3>
          <h3>Відповідь:</h3>
          <p>
            1 Component та Input є необхідними імпортами для цього компонента, але Output не використовується тут, тому це твердження є неправильним.
            <br />
            2 Лише animal є обовязковим а noise ні
            {' '}
            <br />
            3 Це твердження є правильним. @Input('animal') створює аліас для властивості animal, який може використовуватись в шаблоні, але не змінює інтерфейс компонента.
            {' '}
            <br />
            4  Це твердження є частково правильним - компонент містить інтерпольоване ім'я тварин та кнопку, прив'язану до методу makeNoise(), але не створює діапазон.
            <br />
            5 Тег
            {' '}
            {`<AnimalNoise>`}
            {' '}
            неправильний - він повинен бути написаний з малих літер (тобто
            {' '}
            {`<animal-noise>`}
            ) та використовувати ім'я компонента, а не селектор. Тому це твердження є неправильним.
            <br />
          </p>

          <h3>
            5. Розглянемо наступний модуль програми:

          </h3>
          <img src={box5} alt="" />
          <h3>
            Які з таких тверджень щодо поведінки маршрутизаторів є правильними?
            (Виберіть усі прийнятні відповіді.)
            <br />
            1.
            Доступ до домашнього компонента можливий лише через перенаправлення кореневої URL-адреси.
            <br />
            2.
            {`Параметр id не є обов'язковим, коли виконується виклик / detail / URL.

`}
            <br />
            3.
            {`Необов'язкові параметри можуть бути передані до будь-якого компонента через параметри запиту ActivatedRoute.
`}
            <br />
            4.
            {`/detail/100 використовуватиме <router-outlet name='route1'> для визначення позиції виду.`}
            <br />
            5.
            {`Route, який перенаправляє на HomeComponent, активується на тих самих маршрутах, якщо властивість pathMatch: 'full' була видалена.
.`}
          </h3>
          <h3>Відповідь:</h3>
          <p>
            Перші три правильні
            <br />
            4 Неправильно - дана URL-адреса містить параметр id, а не ім'я виду
            <br />
            5 Неправильно -  властивість pathMatch: 'full' означає, що шлях повинен співпадати повністю, включаючи початок і кінець URL-адреси
          </p>

          <h3>
            6. Розглянемо наступні два базові класи, Positionable і Rotatable, і похідний клас MovingObject:

          </h3>
          <img src={box6} alt="" />
          <h3>
            Виберіть правильні твердження.
            (Виберіть усі прийнятні відповіді.)
            <br />
            1.
            Функція applyMixins застосовує реалізації Positionable і Rotatable до MovingObject.
            <br />
            2.
            {`Компілятор TypeScript підкреслить, що властивість "align" відсутня для типу MovingObject.
.
`}
            <br />
            3.
            {`Оскільки MovingObject реалізує Rotatable, виклик mover.rotate(30) нічого не зробить.

`}
            <br />
            4.
            {` Клас Positionable можна змінити на інтерфейс без помилок компілятора.
`}
            <br />
            5.
            Властивості MovingObject необхідні як резервні для задоволення компілятора TypeScript.
          </h3>
          <h3>Відповідь:</h3>
          <p>1 - Функція applyMixins застосовує реалізації Positionable і Rotatable до MovingObject - правильне.</p>

          <h3>
            7. Розглянемо такі компоненти:

          </h3>
          <img src={box7} alt="box" />
          <h3>
            Нижче наведено файл address-list.component.html. Заповніть пробіли, щоб шаблон відображав один елемент li на адресу, і коректно пов'язував кожну адресу з полем AddressComponent.
            <br />
            {`<ul>`}
            {' '}
            <br />
            {`
        <li ="let address of ">`}
            <br />
            {`
            <app-address ="address"></app-address>`}
            <br />
            {`
        </li>`}
            {' '}
            <br />
            {`
    </ul>`}
            <br />

          </h3>
          <h3>Відповідь:</h3>
          <p>
            Для того щоб код працював потрібно внести такі зміни:
            {' '}
            {`<ul>
    <li *ngFor="let address of addresses">
        <app-address [address]="address"></app-address>
    </li>

</ul>`}
            {' '}
            <br />
            {' '}
            В даному шаблоні використовується структурна директива *ngFor, щоб ітерувати по масиву addresses та відображати кожну адресу в окремому елементі li.

          </p>
        </section>
      ) : (
        <button
          className="but"
          type="button"
          onClick={() => {
            handleOpen();
          }}
        >
          <p>Open answers about Angular</p>
        </button>
      )}
    </div>
  );
};
